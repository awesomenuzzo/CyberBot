Public Key Encryption with keyword Search
Dan Boneh‚àó
Stanford University

Giovanni Di Crescenzo
Telcordia

Rafail Ostrovsky‚Ä†
UCLA

Giuseppe Persiano‚Ä°
UniversitaÃÄ di Salerno

Abstract
We study the problem of searching on data that is encrypted using a public key system.
Consider user Bob who sends email to user Alice encrypted under Alice‚Äôs public key. An email
gateway wants to test whether the email contains the keyword ‚Äúurgent‚Äù so that it could route
the email accordingly. Alice, on the other hand does not wish to give the gateway the ability to
decrypt all her messages. We define and construct a mechanism that enables Alice to provide a
key to the gateway that enables the gateway to test whether the word ‚Äúurgent‚Äù is a keyword in
the email without learning anything else about the email. We refer to this mechanism as Public
Key Encryption with keyword Search. As another example, consider a mail server that stores
various messages publicly encrypted for Alice by others. Using our mechanism Alice can send
the mail server a key that will enable the server to identify all messages containing some specific
keyword, but learn nothing else. We define the concept of public key encryption with keyword
search and give several constructions.

1

Introduction

Suppose user Alice wishes to read her email on a number of devices: laptop, desktop, pager, etc.
Alice‚Äôs mail gateway is supposed to route email to the appropriate device based on the keywords
in the email. For example, when Bob sends email with the keyword ‚Äúurgent‚Äù the mail is routed to
Alice‚Äôs pager. When Bob sends email with the keyword ‚Äúlunch‚Äù the mail is routed to Alice‚Äôs desktop
for reading later. One expects each email to contain a small number of keywords. For example,
all words on the subject line as well as the sender‚Äôs email address could be used as keywords. The
mobile people project [24] provides this email processing capability.
Now, suppose Bob sends encrypted email to Alice using Alice‚Äôs public key. Both the contents of
the email and the keywords are encrypted. In this case the mail gateway cannot see the keywords
and hence cannot make routing decisions. As a result, the mobile people project is unable to process
secure email without violating user privacy. Our goal is to enable Alice to give the gateway the
ability to test whether ‚Äúurgent‚Äù is a keyword in the email, but the gateway should learn nothing
else about the email. More generally, Alice should be able to specify a few keywords that the mail
gateway can search for, but learn nothing else about incoming mail. We give precise definitions in
section 2.
‚àó

Supported by NSF and the Packard foundation.
Partially supported by a gift from Teradata. Preliminary work done while visiting Stanford and while at Telcordia.
‚Ä°
Part of this work done while visiting DIMACS. Work supported by NoE ECRYPT.
‚Ä†

1

To do so, Bob encrypts his email using a standard public key system. He then appends to the
resulting ciphertext a Public-Key Encryption with keyword Search (PEKS) of each keyword. To
send a message M with keywords W1 , . . . , Wm Bob sends
EApub (M ) k PEKS(Apub , W1 ) k ¬∑ ¬∑ ¬∑ k PEKS(Apub , Wm )
Where Apub is Alice‚Äôs public key. The point of this form of encryption is that Alice can give the
gateway a certain trapdoor TW that enables the gateway to test whether one of the keywords
associated with the message is equal to the word W of Alice‚Äôs choice. Given PEKS(A pub , W 0 ) and
TW the gateway can test whether W = W 0 . If W 6= W 0 the gateway learns nothing more about W 0 .
Note that Alice and Bob do not communicate in this entire process. Bob generates the searchable
encryption for W 0 just given Alice‚Äôs public key.
In some cases, it is instructive to view the email gateway as an IMAP or POP email server.
The server stores many emails and each email contains a small number of keywords. As before, all
these emails are created by various people sending mail to Alice encrypted using her public key. We
want to enable Alice to ask queries of the form: do any of the messages on the server contain the
keyword ‚Äúurgent‚Äù? Alice would do this by giving the server a trapdoor T W , thus enabling the server
to retrieve emails containing the keyword W . The server learns nothing else about the emails.
Related work. A related issue deals with privacy of database data. There are two different
scenarios: public databases and private databases, and the solutions for each are different.
Private databases: In this settings a user wishes to upload its private data to a remote database and
wishes to keep the data private from the remote database administrator. Later, the user must be
able to retrieve from the remote database all records that contain a particular keyword. Solutions
to this problem were presented in the early 1990‚Äôs by Ostrovsky [26] and Ostrovsky and Goldreich
[17] and more recently by Song at al. [28]. The solution of Song. at al [28] requires very little
communication between the user and the database (proportional to the security parameter) and
only one round of interaction. The database performs work that is linear in its size per query.
The solution of [26, 17] requires poly-logarithmic rounds (in the size of the database) between
the user and the database, but allows the database to do only poly-logarithmic work per query.
An additional privacy requirement that might be appealing in some scenarios is to hide from the
database administrator any information regarding the access pattern, i.e. if some item was retrieved
more then once, some item was not retrieved at all, etc. The work of [26, 17] achieves this property
as well, with the same poly-logarithmic cost1 per query both for the database-user interaction and
the actual database work. We stress that both the constructions of [26, 17] and the more recent
work of [10, 28, 16] apply only to the private-key setting for users who own their data and wish to
upload it to a third-party database that they do not trust.
Public Databases Here the database data is public (such as stock quotes) but the user is unaware
of it and wishes to retrieve some data-item or search for some data-item, without revealing to the
database administrator which item it is. The naive solution is that the user can download the
entire database. Public Information Retrieval (PIR) protocols allow user to retrieve data from a
public database with far smaller communication then just downloading the entire database. PIR
was first shown to be possible only in the setting where there are many copies of the same database
and none of the copies can talk to each other [5]. PIR was shown to be possible for a single
database by Kushilevitz and Ostrovsky [22] (using homomorphic encryption scheme of [19]). The
communication complexity of [22] solution (i.e. the number of bits transmitted between the user
1

The poly-logarithmic construction of [26, 17] requires large constants, which makes it impractical; however their
‚àö
basic O( n) solution was recently shown to be applicable for some practical applications [10].

2

and the database) is O(n ), where n is the size of the database and  > 0. This was reduced to
poly-logarithmic overhead by Cachin, Micali, and Stadler [4]. As pointed out in [22], the model of
PIR can be extended to one-out-of-n Oblivious Transfer and keyword searching on public data, and
received a lot of additional attention in the literature (see, for example, [22, 8, 20, 9, 23, 25, 27].
We stress though that in all these settings the database is public, and the user is trying to retrieve
or find certain items without revealing to the database administrator what it is searching for. In
the setting of a single public database, it can be shown that the database must always perform
work which is at least linear in the size of the database.
Our problem does not fit either of the two models mentioned above. Unlike the private-key
setting, data collected by the mail-server is from third parties, and can not be ‚Äúorganized‚Äù by the
user in any convenient way. Unlike the publicly available database, the data is not public, and
hence the PIR solutions do not apply.
We point out that in practical applications, due to the computation cost of public key encryption,
our constructions are applicable to searching on a small number of keywords rather than an entire
file. Recently, Waters et al. [30] showed that public key encryption with keyword search can be
used to build an encrypted and searchable audit log. Other methods for searching on encrypted
data are described in [16, 12].

2

Public key encryption with searching: definitions

Throughout the paper we use the term negligible function to refer to a function f : R ‚Üí [0, 1] where
f (s) < 1/g(s) for any polynomial g and sufficiently large s.
We start by precisely defining what is a secure Public Key Encryption with keyword Search
(PEKS) scheme. Here ‚Äúpublic-key‚Äù refers to the fact that ciphertexts are created by various people
using Alice‚Äôs public key. Suppose user Bob is about to send an encrypted email to Alice with
keywords W1 , . . . , Wk (e.g., words in the subject line and the sender‚Äôs address could be used as
keywords, so that k is relatively small). Bob sends the following message:


(1)
EApub [msg], PEKS(Apub , W1 ), . . . , PEKS(Apub , Wk )
where Apub is Alice‚Äôs public key, msg is the email body, and PEKS is an algorithm with properties
discussed below. The PEKS values do not reveal any information about the message, but enable
searching for specific keywords. For the rest of the paper, we use as our sample application a mail
server that stores all incoming email.
Our goal is to enable Alice to send a short secret key TW to the mail server that will enable
the server to locate all messages containing the keyword W , but learn nothing else. Alice produces
this trapdoor TW using her private key. The server simply sends the relevant emails back to Alice.
We call such a system non-interactive public key encryption with keyword search, or as a shorthand
‚Äúsearchable public-key encryption‚Äù.
Definition 2.1. A non-interactive public key encryption with keyword search (we sometimes abbreviate it as ‚Äúsearchable encryption‚Äù) scheme consists of the following polynomial time randomized
algorithms:
1. KeyGen(s): Takes a security parameter, s, and generates a public/private key pair A pub , Apriv .
2. PEKS(Apub , W ): for a public key Apub and a word W , produces a searchable encryption of W .
3. Trapdoor(Apriv , W ): given Alice‚Äôs private key and a word W produces a trapdoor TW .
4. Test(Apub , S, TW ): given Alice‚Äôs public key, a searchable encryption S = PEKS(Apub , W 0 ), and
a trapdoor TW = Trapdoor(Apriv , W ), outputs ‚Äòyes‚Äô if W = W 0 and ‚Äòno‚Äô otherwise.
3

Alice runs the KeyGen algorithm to generate her public/private key pair. She uses Trapdoor
to generate trapdoors TW for any keywords W that she wants the mail server or mail gateway to
search for. The mail server uses the given trapdoors as input to the Test() algorithm to determine
whether a given email contains one of the keywords W specified by Alice.
Next, we define security for a PEKS in the sense of semantic-security. We need to ensure that an
PEKS(Apub , W ) does not reveal any information about W unless TW is available. We define security
against an active attacker who is able to obtain trapdoors TW for any W of his choice. Even under
such attack the attacker should not be able to distinguish an encryption of a keyword W 0 from an
encryption of a keyword W1 for which he did not obtain the trapdoor. Formally, we define security
against an active attacker A using the following game between a challenger and the attacker (the
security parameter s is given to both players as input).
PEKS Security game:
1. The challenger runs the KeyGen(s) algorithm to generate Apub and Apriv . It gives Apub to
the attacker.
2. The attacker can adaptively ask the challenger for the trapdoor T W for any keyword
W ‚àà {0, 1}‚àó of his choice.
3. At some point, the attacker A sends the challenger two words W0 , W1 on which it wishes
to be challenged. The only restriction is that the attacker did not previously ask for the
trapdoors TW0 or TW1 . The challenger picks a random b ‚àà {0, 1} and gives the attacker
C = PEKS(Apub , Wb ). We refer to C as the challenge PEKS.
4. The attacker can continue to ask for trapdoors TW for any keyword W of his choice as
long as W 6= W0 , W1 .
5. Eventually, the attacker A outputs b0 ‚àà {0, 1} and wins the game if b = b0 .
In other words, the attacker wins the game if he can correctly guess whether he was given the
PEKS for W0 or W1 . We define A‚Äôs advantage in breaking the PEKS as
1
AdvA (s) = | Pr[b = b0 ] ‚àí |
2
Definition 2.2. We say that a PEKS is semantically secure against an adaptive chosen keyword
attack if for any polynomial time attacker A we have that AdvA (s) is a negligible function.
Chosen Ciphertext Security. We note that Definition 2.2 ensures that the construction given
in Eq. (1) is semantically secure whenever the public key encryption system EApub is semantically
secure. However, as is, the construction is not chosen ciphertext secure. Indeed, a chosen ciphertext attacker can break semantic security by reordering the keywords in Eq. (1) and submitting
the resulting ciphertext for decryption. A standard technique can make this construction chosen
ciphertext secure using the methods of [7]. We defer this to the full version of the paper.

2.1

PEKS implies Identity Based Encryption

Public key encryption with keyword search is related to Identity Based Encryption (IBE) [29, 2].
Constructing a secure PEKS appears to be a harder problem than constructing an IBE. Indeed, the
following lemma shows that PEKS implies Identity Based Encryption. The converse is probably
false. Security notions for IBE, and in particular chosen ciphertext secure IBE (IND-ID-CCA), are
defined in [2].

4

Lemma 2.3. A non-interactive searchable encryption scheme (PEKS) that is semantically secure
against an adaptive chosen keyword attack gives rise to a chosen ciphertext secure IBE system
(IND-ID-CCA).
Proof sketch: Given a PEKS (KeyGen, PEKS, Trapdoor, Test) the IBE system is as follows:
1. Setup: Run the PEKS KeyGen algorithm to generate Apub /Apriv . The IBE system parameters
are Apub . The master-key is Apriv .
2. KeyGen: The IBE private key associated with a public key X ‚àà {0, 1}‚àó is
dX = [Trapdoor(Apriv , Xk0), Trapdoor(Apriv , Xk1)] ,
where k denotes concatenation.
3. Encrypt: Encrypt a bit b ‚àà {0, 1} using a public key X ‚àà {0, 1}‚àó as: CT = PEKS(Apub , Xkb).
4. Decrypt: To decrypt CT = PEKS(Apub , Xkb) using the private key dX = (d0 , d1 ).
Output ‚Äò0‚Äô if Test(Apub , CT, d0 ) = ‚Äòyes‚Äô and output ‚Äò1‚Äô if Test(Apub , CT, d1 ) = ‚Äòyes‚Äô
One can show that the resulting system is IND-ID-CCA assuming the PEKS is semantically secure
against an adaptive chosen message attack.
This shows that building non-interactive public-key searchable encryption is at least as hard as
building an IBE system. One might be tempted to prove the converse (i.e., IBE implies PEKS) by
defining
PEKS(Apub , W ) = EW [0k ]

(2)

i.e. encrypt a string of k zeros with the IBE public key W ‚àà {0, 1}‚àó . The Test algorithm attempts to
decrypt EW [0] and checks that the resulting plaintext is 0k . Unfortunately, this does not necessarily
give a secure searchable encryption scheme. The problem is that the ciphertext CT could expose the
public key (W ) used to create CT . Generally, an encryption scheme need not hide the public key
that was used to create a given ciphertext. But this property is essential for the PEKS construction
given in (2). We note that public key privacy was previously studied by Bellare et al. [1]. The
construction in (2) requires an IBE system that is public-key private.
Generally, it appears that constructing a searchable public-key encryption is a harder problem
than constructing an IBE scheme. Nevertheless, our first PEKS construction is based on a recent
construction for an IBE system. We are able to prove security by exploiting extra properties of
this system.

3

Constructions

We give two constructions for public-key searchable encryption: (1) an efficient system based on
a variant of the Decision Diffie-Hellman assumption (assuming a random oracle) and (2) a limited
system based on general trapdoor permutations (without assuming the random oracle), but less
efficient.

5

3.1

Construction using bilinear maps

Our first construction is based on a variant of the Computational Diffie-Hellman problem. Boneh
and Franklin [2] recently used bilinear maps on elliptic curves to build an efficient IBE system.
Abstractly, they use two groups G1 , G2 of prime order p and a bilinear map e : G1 √ó G1 ‚Üí G2
between them. The map satisfies the following properties:
1. Computable: given g, h ‚àà G1 there is a polynomial time algorithms to compute e(g, h) ‚àà G2 .
2. Bilinear: for any integers x, y ‚àà [1, p] we have e(g x , g y ) = e(g, g)xy
3. Non-degenerate: if g is a generator of G1 then e(g, g) is a generator of G2 .
The size of G1 , G2 is determined by the security parameter.
We build a non-interactive searchable encryption scheme from such a bilinear map. The construction is based on [2]. We will need hash functions H1 : {0, 1}‚àó ‚Üí G1 and H2 : G2 ‚Üí {0, 1}log p .
Our PEKS works as follows:
‚Ä¢ KeyGen: The input security parameter determines the size, p, of the groups G 1 and G2 . The
algorithm picks a random Œ± ‚àà Z‚àóp and a generator g of G1 . It outputs Apub = [g, h = g Œ± ] and
Apriv = Œ±.
‚Ä¢ PEKS(Apub , W ): First compute t = e(H1 (W ), hr ) ‚àà G2 for a random r ‚àà Z‚àóp .
Output PEKS(Apub , W ) = [g r , H2 (t)].
‚Ä¢ Trapdoor(Apriv , W ): output TW = H1 (W )Œ± ‚àà G1 .
‚Ä¢ Test(Apub , S, TW ): let S = [A, B]. Test if H2 (e(TW , A)) = B.
If so, output ‚Äòyes‚Äô; if not, output ‚Äòno‚Äô.
We prove that this system is a non-interactive searchable encryption scheme semantically secure
against a chosen keyword attack in the random oracle model. The proof of security relies on the
difficulty of the Bilinear Diffie-Hellman problem (BDH) [2, 21].
Bilinear Diffie-Hellman Problem (BDH): Fix a generator g of G1 . The BDH problem is as
follows: given g, g a , g b , g c ‚àà G1 as input, compute e(g, g)abc ‚àà G2 . We say that BDH is intractable
if all polynomial time algorithms have a negligible advantage in solving BDH.
We note that the Boneh-Franklin IBE system [2] relies on the same intractability assumption
for security. The security of our PEKS is proved in the following theorem. The proof is set in the
random oracle model. Indeed, it is currently an open problem to build a secure IBE, and hence a
PEKS, without the random oracle model.
Theorem 3.1. The non-interactive searchable encryption scheme (PEKS) above is semantically
secure against a chosen keyword attack in the random oracle model assuming BDH is intractable.
Proof : Suppose A is an attack algorithm that has advantage  in breaking the PEKS. Suppose A
makes at most qH2 hash function queries to H2 and at most qT trapdoor queries (we assume qT and
qH2 are positive). We construct an algorithm B that solves the BDH problem with probability at
least 0 = /(eqT qH2 ), where e is the base of the natural logarithm. Algorithm B‚Äôs running time is
approximately the same as A‚Äôs. Hence, if the BDH assumption holds in G1 then 0 is a negligible
function and consequently  must be a negligible function in the security parameter.
Let g be a generator of G1 . Algorithm B is given g, u1 = g Œ± , u2 = g Œ≤ , u3 = g Œ≥ ‚àà G1 . Its goal is
to output v = e(g, g)Œ±Œ≤Œ≥ ‚àà G2 . Algorithm B simulates the challenger and interacts with forger A
as follows:
6

KeyGen. Algorithm B starts by giving A the public key Apub = [g, u1 ].
H1 , H2 -queries. At any time algorithm A can query the random oracles H1 or H2 . To respond to
H1 queries algorithm B maintains a list of tuples hWj , hj , aj , cj i called the H1 -list. The list is
initially empty. When A queries the random oracle H1 at a point Wi ‚àà {0, 1}‚àó , algorithm B
responds as follows:
1. If the query Wi already appears on the H1 -list in a tuple hWi , hi , ai , ci i then algorithm B
responds with H1 (Wi ) = hi ‚àà G1 .
2. Otherwise, B generates a random coin ci ‚àà {0, 1} so that Pr[ci = 0] = 1/(qT + 1).
3. Algorithm B picks a random ai ‚àà Zp .
If ci = 0, B computes hi ‚Üê u2 ¬∑ g ai ‚àà G1 .
If ci = 1, B computes hi ‚Üê g ai ‚àà G1 .
4. Algorithm B adds the tuple hWi , hi , ai , ci i to the H1 -list and responds to A by setting
H1 (Wi ) = hi . Note that either way hi is uniform in G1 and is independent of A‚Äôs current
view as required.
Similarly, at any time A can issue a query to H2 . Algorithm B responds to a query for H2 (t)
by picking a new random value V ‚àà {0, 1}log p for each new t and setting H2 (t) = V . In
addition, B keeps track of all H2 queries by adding the pair (t, V ) to an H2 -list. The H2 -list
is initially empty.
Trapdoor queries. When A issues a query for the trapdoor corresponding to the word W i algorithm B responds as follows:
1. Algorithm B runs the above algorithm for responding to H1 -queries to obtain an hi ‚àà G1
such that H1 (Wi ) = hi . Let hWi , hi , ai , ci i be the corresponding tuple on the H1 -list. If
ci = 0 then B reports failure and terminates.
2. Otherwise, we know ci = 1 and hence hi = g ai ‚àà G1 . Define Ti = ua1i . Observe that
Ti = H(Wi )Œ± and therefore Ti is the correct trapdoor for the keyword Wi under the
public key Apub = [g, u1 ]. Algorithm B gives Ti to algorithm A.
Challenge. Eventually algorithm A produces a pair of keywords W0 and W1 that it wishes to be
challenged on. Algorithm B generates the challenge PEKS as follows:
1. Algorithm B runs the above algorithm for responding to H1 -queries twice to obtain a
h0 , h1 ‚àà G1 such that H1 (W0 ) = h0 and H1 (W1 ) = h1 . For i = 0, 1 let hWi , hi , ai , ci i be
the corresponding tuples on the H1 -list. If both c0 = 1 and c1 = 1 then B reports failure
and terminates.
2. We know that at least one of c0 , c1 is equal to 0. Algorithm B randomly picks a b ‚àà {0, 1}
such that cb = 0 (if only one cb is equal to 0 then no randomness is needed since there
is only one choice).
3. Algorithm B responds with the challenge PEKS C = [u3 , J] for a random J ‚àà {0, 1}log p .
Note that this challenge implicitly defines H2 (e(H1 (Wb ), uŒ≥1 )) = J. In other words,
J = H2 (e(H1 (Wb ), uŒ≥1 )) = H2 (e(u2 g ab , g Œ±Œ≥ )) = H2 (e(g, g)Œ±Œ≥(Œ≤+ab ) )
With this definition, C is a valid PEKS for Wb as required.
More trapdoor queries. A can continue to issue trapdoor queries for keywords W i where the
only restriction is that Wi 6= W0 , W1 . Algorithm B responds to these queries as before.
7

Output. Eventually, A outputs its guess b0 ‚àà {0, 1} indicating whether the challenge C is the result
of PEKS(Apub , W0 ) or PEKS(Apub , W1 ). At this point, algorithm B picks a random pair (t, V )
from the H2 -list and outputs t/e(u1 , u3 )ab as its guess for e(g, g)Œ±Œ≤Œ≥ , where ab is the value
used in the Challenge step. The reason this works is that, as we will show, A must have issued
a query for either H2 (e(H1 (W0 ), uŒ≥1 )) or H2 (e(H1 (W1 ), uŒ≥1 )). Therefore, with probability 1/2
the H2 -list contains a pair whose left hand side is t = e(H1 (Wb ), uŒ≥1 ) = e(g, g)Œ±Œ≥(Œ≤+ab ) . If B
picks this pair (t, V ) from the H2 -list then t/e(u1 , u3 )ab = e(g, g)Œ±Œ≤Œ≥ as required.
This completes the description of algorithm B. It remains to show that B correctly outputs
e(g, g)Œ±Œ≤Œ≥ with probability at least 0 . To do so, we first analyze the probability that B does
not abort during the simulation. We define two events:
E1 : B does not abort as a result of any of A‚Äôs trapdoor queries.
E2 : B does not abort during the challenge phase.
We first argue as in [6] that both events E1 and E2 occur with sufficiently high probability.
Claim 1: The probability that algorithm B does not abort as a result of A‚Äôs trapdoor queries is
at least 1/e. Hence, Pr[E1 ] ‚â• 1/e.
Proof. Without loss of generality we assume that A does not ask for the trapdoor of the same
keyword twice. The probability that a trapdoor query causes B to abort is 1/(q T + 1). To see this,
let Wi be A‚Äôs i‚Äôth trapdoor query and let hWi , hi , ai , ci i be the corresponding tuple on the H1 -list.
Prior to issuing the query, the bit ci is independent of A‚Äôs view ‚Äî the only value that could be
given to A that depends on ci is H(Wi ), but the distribution on H(Wi ) is the same whether ci = 0
or ci = 1. Therefore, the probability that this query causes B to abort is at most 1/(q T + 1).
Since A makes at most qT trapdoor queries the probability that B does not abort as a result of all
trapdoor queries is at least (1 ‚àí 1/(qT + 1))qT ‚â• 1/e.
Claim 2: The probability that algorithm B does not abort during the challenge phase is at least
1/qT . Hence, Pr[E2 ] ‚â• 1/qT .
Proof. Algorithm B will abort during the challenge phase if A is able to produce W 0 , W1 with the
following property: c0 = c1 = 1 where for i = 0, 1 the tuple hWi , hi , ai , ci i is the tuple on the H1 -list
corresponding to Wi . Since A has not queried for the trapdoor for W0 , W1 we have that both c0 , c1
are independent of A‚Äôs current view. Therefore, since Pr[ci = 0] = 1/(qT +1) for i = 0, 1, and the two
values are independent of one another, we have that Pr[c0 = c1 = 1] = (1 ‚àí 1/(qT + 1))2 ‚â§ 1 ‚àí 1/qT .
Hence, the probability that B does not abort is at least 1/qT .
Observe that since A can never issue a trapdoor query for the challenge keywords W 0 , W1 the
two events E1 and E2 are independent. Therefore, Pr[E1 ‚àß E2 ] ‚â• 1/(eqT ).
To complete the proof of Theorem 3.1 it remains to show that B outputs the solution to the
given BDH instance with probability at least /qH2 . To do we show that during the simulation A
issues a query for H2 (e(H1 (Wb ), uŒ≥1 )) with probability at least .
Claim 3: Suppose that in a real attack game A is given the public key [g, u1 ] and A asks to be
challenged on words W0 and W1 . In response, A is given a challenge C = [g r , J]. Then, in the
real attack game A issues an H2 query for either H2 (e(H1 (W0 ), ur1 )) or H2 (e(H1 (W1 ), ur1 )) with
probability at least 2.
Proof. Let E3 be the event that in the real attack A does not issue a query for either one of
H2 (e(H1 (W0 ), ur1 )) and H2 (e(H1 (W1 ), ur1 )). Then, when E3 occurs we know that the bit b ‚àà {0, 1}
8

indicating whether C is a PEKS of W0 or W1 is independent of A‚Äôs view. Therefore, A‚Äôs output b0
will satisfy b = b0 with probability at most 21 . By definition of A, we know that in the real attack
| Pr[b = b0 ] ‚àí 1/2| ‚â• . We show that these two facts imply that Pr[¬¨E3 ] ‚â• 2. To do so, we first
derive simple upper and lower bounds on Pr[b = b0 ]:
Pr[b = b0 ] = Pr[b = b0 |E3 ] Pr[E3 ] + Pr[b = b0 |¬¨E3 ] Pr[¬¨E3 ]
1
‚â§ Pr[b = b0 |E3 ] Pr[E3 ] + Pr[¬¨E3 ] = Pr[E3 ] + Pr[¬¨E3 ]
2
1 1
+ Pr[¬¨E3 ],
=
2 2
1
1 1
Pr[b = b0 ] ‚â• Pr[b = b0 |E3 ] Pr[E3 ] = Pr[E3 ] = ‚àí Pr[¬¨E3 ].
2
2 2
It follows that  ‚â§ | Pr[b = b0 ] ‚àí 1/2| ‚â§ 12 Pr[¬¨E3 ]. Therefore, in the real attack, Pr[¬¨E3 ] ‚â• 2 as
required.
Now, assuming B does not abort, we know that B simulates a real attack game perfectly up to
the moment when A issues a query for either H2 (e(H1 (W0 ), uŒ≥1 )) or H2 (e(H1 (W1 ), uŒ≥1 )). Therefore,
by Claim 3, by the end of the simulation A will have issued a query for either H2 (e(H1 (W0 ), uŒ≥1 )) or
H2 (e(H1 (W1 ), uŒ≥1 )) with probability at least 2. It follows that A issues a query for H2 (e(H1 (Wb ), uŒ≥1 ))
with probability at least . Consequently, the value e(H1 (Wb ), uŒ≥1 ) = e(g Œ≤+ab , g)Œ±Œ≥ will appear on
the left hand side of some pair in the H2 -list. Algorithm B will choose the correct pair with probability at least 1/qH2 and therefore, assuming B does not abort during the simulation, it will produce
the correct answer with probability at least /qH2 . Since B does not abort with probability at least
1/(eqT ) we see that B‚Äôs success probability overall is at least /(eqT qH2 ) as required.

3.2

A limited construction using any trapdoor permutation

Our second PEKS construction is based on general trapdoor permutations, assuming that the total
number of keywords that the user wishes to search for is bounded by some polynomial function
in the security parameter. (As a first step in our construction, we will make an even stronger
assumption that the total number of words Œ£ ‚äÇ {0, 1}‚àó in the dictionary is also bounded by a
polynomial function, we will later show how to remove this additional assumption.) We will also
need a family of semantically-secure encryptions where given a ciphertext it is computationally hard
to say which public-key this ciphertext is associated with. This notion was formalized by Bellare
et al. [1]. We say that a public-key system that has this property is source-indistinguishable.
More precisely, source-indistinguishability for an encryption scheme (G, E, D) is defined using the
following game between a challenger and an attacker A (here G is the key generation algorithm,
and E/D are encryption/decryption algorithms). The security parameter s is given to both players.
Source Indistinguishability security game:
1. The challenger runs algorithm G(s) two times to generate two public/private key pairs
(P K0 , P riv0 ) and (P K1 , P riv1 ).
2. The challenger picks a random M ‚àà {0, 1}s and a random b ‚àà {0, 1} and computes an
encryption C = P Kb (M ). The challenger gives (M, C) to the attacker.
3. The attacker outputs b0 and wins the game if b = b0 .
In other words, the attacker wins if he correctly guesses whether he was given the encryption
of M under P K0 or under P K1 . We define A‚Äôs advantage in winning the game as:
1
AdvSIA (s) = | Pr[b = b0 ] ‚àí |
2
9

Definition 3.2. We say that a public-key encryption scheme is source indistinguishable if for any
polynomial time attacker A we have that AdvSIA (s) is a negligible function.
We note that Bellare et al. [1] define a stronger notion of source indistinguishability than the
one above by allowing the adversary to choose the challenge message M . For our purposes, giving
the adversary an encryption of a random message is sufficient.
Source indistinguishability can be attained from any trapdoor permutation family, where for a
given security parameter all permutations in the family are defined over the same domain. Such a
family can be constructed from any family of trapdoor permutations as described in [1]. Then to
encrypt a bit b we pick a random x, and output [f (x), GL(x) ‚äï b] where GL is the Goldreich-Levin
hard-core bit [19]. We therefore obtain the following lemma:
Lemma 3.3. Given any trapdoor permutation family we can construct a semantically secure source
indistinguishable encryption scheme.
More constructions are given in [1]. We note that source indistinguishability is an orthogonal
property to semantic security. One can build a semantically secure system that is not source
indistinguishable (by embedding the public key in every ciphertext). Conversely, one can build
a source indistinguishable system that is not semantically secure (by embedding the plaintext in
every ciphertext).
A simple PEKS from trapdoor permutations. When the keyword family Œ£ is of polynomial
size (in the security parameter) it is easy to construct searchable encryption from any sourceindistinguishable public-key system (G, E, D). We let s be the security parameter for the scheme.
‚Ä¢ KeyGen: For each W ‚àà Œ£ run G(s) to generate a new public/private key pair P K W /P riv W
for the source-indistinguishable encryption scheme. The PEKS public key is
Apub = {P K W | W ‚àà Œ£}. The private key is Apriv = {P riv W | W ‚àà Œ£}.
‚Ä¢ PEKS(Apub , W ): Pick a random M ‚àà {0, 1}s and output PEKS(Apub , W ) = (M, E[P K W , M ]),
i.e. encrypt M using the public key P K W .
‚Ä¢ Trapdoor(Apriv , W ): The trapdoor for word W is simply TW = P riv W .
‚Ä¢ Test(Apub , S, TW ): Test if the decryption D[TW , S] = 0s . Output ‚Äòyes‚Äô if so and ‚Äòno‚Äô otherwise.
Note that the dictionary must be of polynomial size (in s) so that the public and private keys are
of polynomial size (in s).
This construction gives a semantically secure PEKS as stated in the following simple theorem.
Semantically secure PEKS is defined as in Definition 2.2 except that the adversary is not allowed
to make chosen keyword queries.
Theorem 3.4. The PEKS scheme above is semantically secure assuming the underlying public key
encryption scheme (G, E, D) is source-indistinguishable.
Proof sketch: Let Œ£ = {W1 , . . . , Wk } be the keyword dictionary. Suppose we have a PEKS
attacker A for which AdvA (s) > (s). We build an attacker B that breaks the source indistinguishability of (G, E, D) where AdvSIB (s) > (s)/k 2 .
The reduction is immediate: B is given two public keys P K0 , P K1 and a pair (M, C) where
M is random in {0, 1}s and C = P Kb (M ) for b ‚àà {0, 1}. Algorithm B generates k ‚àí 2 additional
public/private keys using G(s). It creates Apub as a list of all k public keys with P K0 , P K1
embedded in a random location in the list. Let Wi , Wj be the words associated with the public
keys P K0 , P K1 . B sends Apub to A who then responds with two words Wk , W` ‚àà Œ£ on which A
wishes to be challenged. If {i, j} 6= {k, `} algorithm B reports failure and aborts. Otherwise, B
10

sends the challenge (M, C) to A who then responds with a b0 ‚àà {0, 1}. Algorithm B outputs b0 as
its response to the source indistinguishability challenge. We have that b = b0 if algorithm B did
not abort and A‚Äôs response was correct. This happens with probability at least 12 + /k 2 . Hence,
AdvSIB (s) > (s)/k 2 as required.
We note that this PEKS can be viewed as derived from an IBE system with a limited number
of identities. For each identity there is a pre-specified public key. Such an IBE system is implied
in the work of Dodis et al. [13]. They propose reducing the size of the public-key using cover-free
set systems. We apply the same idea below to reduce the size of the public key in the PEKS above.
Reducing the public key size. The drawback of the above scheme is that the public key length
grows linearly with the total dictionary size. If we have an upper-bound on the total number of
keyword trapdoors that the user will release to the email gateway (though we do not need to know
these keywords a-priori) we can do much better using cover-free families [15] and can allow keyword
dictionary to be of exponential size. Since typically a user will only allow a third party (such as
e-mail server) to search for a limited number of keywords so that assuming an upper bound on the
number of released trapdoors is within reason. We begin by recalling the definition of cover-free
families.
Definition 3.5. Cover-free families. Let d, t, k be positive integers, let G be a ground set of size
d, and let F = {S1 , . . . , Sk } be a family of subsets of G. We say that subset Sj does not cover Si if
it holds that Si 6‚äÜ Sj . We say that family F is t-cover free over G if each subset in F is not covered
by the union of t subsets in F . Moreover, we say that a family of subsets is q-uniform if all subsets
in the family have size q.
We will use the following fact from [14].
Lemma 3.6. [14] There exists a deterministic algorithm that, for any fixed t, k, constructs a
q-uniform t-cover free family F over a ground set of size d, for q = dd/4te and d ‚â§ 16t 2 (1 +
log(k/2)/ log 3).
The PEKS. Given the previous PEKS construction as a starting point, we can significantly reduce
the size of public file Apub by allowing user to re-use individual public keys for different keywords.
We associate to each keyword a subset of public keys chosen from a cover free family. Let k be the
size of the dictionary Œ£ = {W1 , . . . , Wk } and let t be an upper bound on the number of keyword
trapdoors released to the mail gateway by user Alice. Let d, q satisfy the bounds of Lemma 3.6.
The PEKS(d, t, k, q) construction is as follows:
‚Ä¢ KeyGen: For i = 1, . . . , d run algorithm G(s) to generate a new public/private key pair
P Ki /P rivi for the source-indistinguishable encryption scheme. The PEKS public key is Apub =
{P K1 , . . . , P Kd }. The private key is Apriv = {P riv1 , . . . , P rivd }. We will be using a q-uniform
t-cover free family of subsets F = {S1 , . . . , Sk } of {P K1 , . . . , P Kd }. Hence, each Si is a subset
of public keys.
‚Ä¢ PEKS(Apub , Wi ): Let Si ‚àà F be the subset associated with the word Wi ‚àà Œ£. Let Si =
{P K (1) , . . . , P K (q) }. Pick random messages M1 , . . . , Mq ‚àà {0, 1}s and let M = M1 ‚äï¬∑ ¬∑ ¬∑‚äïMq .
Output the tuple:


PEKS(Apub , Wi ) = M, E[P K (1) , M1 ], . . . , E[P K (q) , Mq ]
‚Ä¢ Trapdoor(Apriv , Wi ): Let Si ‚àà F be the subset associated with word Wi ‚àà Œ£. The trapdoor
for word Wi is simply the set of private keys that correspond to the public keys in the set Si .
11

‚Ä¢ Test(Apub , R, TW ):
Let TW = {P riv (1) , . . . , P riv (q) } and let R = (M, C1 , . . . , Cq ) be a PEKS. For i = 1, . . . , q
decrypt each Ci using private key P riv (i) to obtain Mi . Output ‚Äòyes‚Äô if M = M1 ‚äï ¬∑ ¬∑ ¬∑ ‚äï Mq ,
and output ‚Äòno‚Äô otherwise.
The size of the public key file Apub is much smaller now: logarithmic in the size of the dictionary.
The downside is that Alice can only release t keywords to the email gateway. Once t trapdoors
are released privacy is no longer guaranteed. Also, notice that the size of the PEKS is larger now
(logarithmic in the dictionary size and linear in t). The following corollary of Theorem 3.4 shows
that the resulting PEKS is secure.
Corollary 3.7. Let d, t, k, q satisfy the bounds of Lemma 3.6. The PEKS(d, t, k, q) scheme above is
semantically secure under a chosen keyword attack assuming the underlying public key encryption
scheme (G, E, D) is source-indistinguishable and semantically secure, and that the adversary makes
no more than t trapdoors queries.
Proof sketch: Let Œ£ = {W1 , . . . , Wk } be the keyword dictionary. Suppose we have a PEKS
attacker A for which AdvA (s) > (s). We build an attacker B that breaks the source indistinguishability of (G, E, D).
Algorithm B is given two public keys P K0 , P K1 and a pair (M, C) where M is random in {0, 1}s
and C = P Kb (M ) for b ‚àà {0, 1}. Its goal is to output a guess for b which it does by interacting
with A. Algorithm B generates d ‚àí 2 additional public/private keys using G(s). It creates A pub as
a list of all d public keys with P K0 , P K1 embedded in a random location in the list. Let Wi , Wj
be the words associated with the public keys P K0 , P K1 .
B sends Apub to A. Algorithm A issues up to t trapdoor queries. B responds to a trapdoor
query for W ‚àà Œ£ as follows: let S ‚àà F be the subset corresponding to the word W . If P K 0 ‚àà S
or P K1 ‚àà S algorithm B reports failure and aborts. Otherwise, B gives A the set of private keys
{P rivi | i ‚àà S}.
At some point, Algorithm A outputs two words W00 , W10 ‚àà Œ£ on which it wishes to be challenged.
Let S00 , S10 ‚àà F be the subsets corresponding to W00 , W10 respectively. Let E be the event that
P K0 ‚àà S00 and P K1 ‚àà S10 . If event E did not happen then B reports failure and aborts.
(1)
(q)
We now know that P K0 ‚àà S00 and P K1 ‚àà S10 . For j = 0, 1 let Sj0 = {P Kj , . . . , P Kj }. We
(c)

(c)

arrange things so that P K0 = P K0 and P K1 = P K1 for some random 1 ‚â§ c ‚â§ q. Next, B
picks random M1 , . . . , Mc‚àí1 , Mc+1 , . . . , Mq ‚àà {0, 1}s and sets Mc = M . Let M 0 = M1 ‚äï ¬∑ ¬∑ ¬∑ ‚äï Mq .
Algorithm B defines the following hybrid tuple:

(1)
(c‚àí1)
R =
M 0 , E[P K0 , M1 ], . . . , E[P K0
, Mc‚àí1 ], C,

(c+1)
(q)
E[P K1
, Mc+1 ], . . . , E[P K1 , Mq ]
It gives R as the challenge PEKS to algorithm A. Algorithm A eventually responds with some
b0 ‚àà {0, 1} indicating whether R is PEKS(Apub , W00 ) or PEKS(Apub , W10 ). Algorithm B outputs b0
as its guess for b. One can show using a standard hybrid argument that if B does not abort then
| Pr[b = b0 ] ‚àí 12 | > /q 2 . The probability that B does not abort at a result of a trapdoor query is at
least 1 ‚àí (tq/d). The probability that B does not abort as a result of the choice of words W 00 , W10
is at least (q/d)2 . Hence, B does not abort with probability at least 1/poly(t, q, d). Repeatedly
running B until it does not abort shows that we can get advantage /q 2 in breaking the source
indistinguishability of (G, E, D) in expected polynomial time in the running time of A.
12

4

Construction using Jacobi symbols

Given the relation between Identity Based Encryption and PEKS it is tempting to construct a PEKS
from an IBE system due to Cocks [3]. The security of Cocks‚Äô IBE system is based on the difficulty
of distinguishing quadratic residues from non-residues modulo N = pq where p = q = 3(mod4).
Unfortunately, Galbraith [11] shows that the Cocks system as described in [3] is not public-key
private in the sense of Bellare et al. [1]. Therefore it appears that the Cocks system cannot be
directly used to construct a PEKS. It provides a good example that constructing a PEKS is a harder
problem than constructing an IBE.
We briefly explain why the basic Cocks system is not public key private. Let N ‚àà Z be a
product of two primes. For a public key x ‚àà ZN and a bit b ‚àà {0, 1} define Px,b to be the set
x
Px,b = { r +
| r ‚àà ZN and (r/N ) = (‚àí1)b } ‚äÜ ZN
r
where (r/N ) denotes the Jacobi symbol of r over N . Fix some b ‚àà {0, 1}. To show that the system
is not public key private it suffices to show an algorithm that given two distinct public keys x and y
in ZN can distinguish the uniform distribution on Px,b from the uniform distribution on Py,b . The
algorithm works as follows (it is given as input x, y ‚àà ZN and z ‚àà ZN where z is either sampled
from Px,b or from Py,b ):
1. Compute t = z 2 ‚àí 4x ‚àà ZN .
2. If the Jacobi symbol (t/N ) = 1 output ‚Äúz ‚àà Px,b ‚Äù. Otherwise output ‚Äúz ‚àà Py,b ‚Äù.
When z is sampled from Px,b then t = z 2 ‚àí 4x = (r ‚àí (x/r))2 and hence t will always have Jacobi
symbol 1 over N . When z is sampled from Py,b then we expect t to have Jacobi symbol 1 over N
with probability about 1/2. Therefore, the algorithm has advantage 1/2 in correctly identifying
where z is sampled from. Since a Cocks ciphertext contains many such samples, the algorithm
above determines whether a ciphertext is encrypted under the public key x or the public key y with
overwhelming probability. Note there is no need to know the plaintext b.

5

Conclusions

We defined the concept of a public key encryption with keyword search (PEKS) and gave two
constructions. Constructing a PEKS is related to Identity Based Encryption (IBE), though PEKS
seems to be harder to construct. We showed that PEKS implies Identity Based Encryption, but
the converse is currently an open problem. Our constructions for PEKS are based on recent IBE
constructions. We are able to prove security by exploiting extra properties of these schemes.

Acknowledgments
We thank Glenn Durfee for suggesting the use of H2 in the construction of Section 3.1. We thank
Yevgeniy Dodis, David Molnar, and Steven Galbraith for helpful comments on this work.

References
[1] M. Bellare, A. Boldyreva, A. Desai, and D. Pointcheval ‚ÄúKey-Privacy in Public-Key Encryption,‚Äù in Advances in Cryptology - Asiacrypt 2001 Proceedings, LNCS Vol. 2248, SpringerVerlag, 2001.
13

[2] D. Boneh and M. Franklin, Identity-based Encryption from the Weil Pairing, SIAM J. of
Computing, Vol. 32, No. 3, pp. 586-615, 2003, Extended abstract in Crypto 2001.
[3] C. Cocks, An identity based encryption scheme based on quadratic residues, Eighth IMA International Conference on Cryptography and Coding, Dec. 2001, Royal Agricultural College,
Cirencester, UK.
[4] C. Cachin, S. Micali, M. Stadler Computationally Private Information Retrieval with Polylogarithmic Communication Eurcrypt 1999.
[5] B. Chor, O. Goldreich, E. Kushilevitz and M. Sudan, Private Information Retrieval, in FOCS
95 (also Journal of ACM).
[6] J. Coron, ‚ÄúOn the exact security of Full-Domain-Hash‚Äù, in Advances in Cryptology ‚Äì Crypto
2000, Lecture Notes in Computer Science, Vol. 1880, Springer-Verlag, pp. 229‚Äì235, 2000.
[7] D. Dolev, C. Dwork, and M. Naor, ‚ÄúNon-Malleable Cryptography,‚Äù in SIAM Journal on Computing, 2000. Early version in proceedings of STOC ‚Äô91.
[8] G. Di Crescenzo, Y. Ishai, and R. Ostrovsky. Universal service-providers for database private
information retrieval. In Proc. of the 17th Annu. ACM Symp. on Principles of Distributed
Computing, pages 91-100, 1998.
[9] G. Di Crescenzo, T. Malkin, and R. Ostrovsky. Single-database private information retrieval
implies oblivious transfer. In Advances in Cryptology - EUROCRYPT 2000, 2000.
[10] A.
Iliev,
S.
Smith
Privacy-enhanced
credential
services.
nual PKI workshop. (see also Darthmoth Technical Report
http://www.cs.dartmouth.edu/ sws/papers/ilsm03.pdf.

Second
anTR-2003-442;

[11] S. Galbraith, private communications.
[12] Y. Desmedt, ‚ÄúComputer security by redefining what a computer is,‚Äù in Proceedings New
Security Paradigms II Workshop, pp. 160‚Äì166, 1992.
[13] Y. Dodis, J. Katz, S. Xu, and M. Yung. ‚ÄúKey-insulated public key cryptosystems,‚Äù in Advances
in Cryptology ‚Äì Eurocrypt 2002, LNCS, Springer-Verlag, pp. 65‚Äì82, 2002.
[14] D. Z. Du and F. K. Hwang, Combinatorial Group Testing and its Applications, World Scientific,
Singapore, 1993.
[15] P. Erdos, P. Frankl and Z. Furedi, Families of finite sets in which no set is covered by the
union of r others, in Israeli Journal of Mathematics, 51: 79‚Äì89, 1985.
[16] E. Goh, ‚ÄúBuilding Secure Indexes for Searching Efficiently on Encrypted Compressed Data,‚Äù
http://eprint.iacr.org/2003/216/
[17] O. Goldreich and R. Ostrovsky. Software protection and simulation by oblivious RAMs. JACM,
1996.
[18] Goldreich, O., S. Goldwasser, and S. Micali, ‚ÄúHow To Construct Random Functions,‚Äù Journal
of the Association for Computing Machinery, Vol. 33, No. 4 (October 1986), 792-807.

14

[19] S. Goldwasser and S. Micali, Probabilistic Encryption, in Journal of Computer and System
Sciences. vol. 28 (1984), n. 2, pp. 270‚Äì299.
[20] Y. Gertner, Y. Ishai, E. Kushilevitz, and T. Malkin Protecting data privacy in private information retrieval schemes. In Proc. of the 30th Annual ACM Symposium on the Theory of
Computing, pp. 151-160, 1998.
[21] A. Joux, ‚ÄúThe Weil and Tate Pairings as Building Blocks for Public Key Cryptosystems‚Äù,
in Proc. Fifth Algorithmic Number Theory Symposium, Lecture Notes in Computer Science,
Springer-Verlag, 2002.
[22] E. Kushilevitz and R. Ostrovsky, Replication is not needed: Single Database, ComputationallyPrivate Information Retrieval, in FOCS 97.
[23] E. Kushilevitz and R. Ostrovsky. One-way Trapdoor Permutations are Sufficient for NonTrivial Single-Database Computationally-Private Information Retrieval. In Proc. of EUROCRYPT ‚Äô00, 2000.
[24] P. Maniatis, M. Roussopoulos, E. Swierk, K. Lai, G. Appenzeller, X. Zhao, and M. Baker, The
Mobile People Architecture. ACM Mobile Computing and Communications Review (MC2R),
Volume 3, Number 3, July 1999.
[25] M. Naor and B. Pinkas. Oblivious transfer and polynomial evaluation. In Proc. of the 31th
Annu. ACM Symp. on the Theory of Computing, pages 245‚Äì254, 1999.
[26] R. Ostrovsky. Software protection and simulation on oblivious RAMs. MIT Ph.D. Thesis, 1992.
Preliminary version in Proc. 22nd Annual ACM Symp. Theory Comp., 1990.
[27] W. Ogata and K. Kurosawa, ‚ÄúOblivious keyword search,‚Äù to appear in J. of Complexity.
[28] D. Song, D. Wagner, and A. Perrig, Practical Techniques for Searches on Encrypted Data, in
Proc. of the 2000 IEEE symposium on Security and Privacy (S&P 2000).
[29] A. Shamir, Identity-based Cryptosystems and Signature Schemes, in CRYPTO 84.
[30] B. Waters, D. Balfanz, G. Durfee, D. Smetters, ‚ÄúBuilding an encrypted and searchable audit
log‚Äù, to appear in NDSS ‚Äô04.

15

